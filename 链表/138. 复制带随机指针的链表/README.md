# 复制带随机指针的链表

## 方案 1（遍历链表 + hash 表保存对应关系）

- 虽然存在 next/ random 指针。但是其实都是指向链表中的任意一个值
- 先遍历链表，同时构建新的链表。保存旧链表节点以及新链表节点的关系
- 再次遍历链表，通过旧链表节点 查询新的链表节点。同时设置链表的 next/ random 关系

## 时间复杂度

> O(n)

- 因为经过了两次链表遍历。所以是 O(2n). 去掉常数项就是 O(n)

## 空间复杂度

> O(n)

- 使用一个 hash 表来存储新旧节点的对应关系。所以是 O(n)

## 方案 2(遍历链表 + 设置新 next 节点)

### 思路

![](../images/%E5%A4%8D%E5%88%B6%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9.png)

- 遍历整个链表，将每个节点的值进行复制。构建一个新的节点。插入的原节点后面
- 所以整个链表中 奇数就是原节点，偶数就是新节点。
- 所以新节点的 random 节点 就是原节点的 random 节点的下一个节点
- 还原链表

```js
let curr = head
while (curr) {
  // 当前节点下个新节点的random = 当前节点random的下个节点
  if (curr.random != null) curr.next.random = curr.random.next
  curr = curr.next.next
}
```

## 时间复杂度

> O(n)

- 因为经过了两次链表遍历。所以是 O(3n). 去掉常数项就是 O(n)

## 空间复杂度

> O(1)

- 只使用了些许变量进行存储。所以是 O(1)的复杂度
