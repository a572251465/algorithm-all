# 链表反转

## 方案 1(while 循环 + 从头反转到尾部)

### 思路

> - 首先使用 while 循环遍历整个节点
> - 原来的链表是`1 => 2 => 3`。 现在的目的就是将指针开始往回指
> - 如下列代码所示：

```js
while (p) {
  // 1. 获取第一个节点
  const firstNode = p
  // 2. 将当前p 设置为第二个节点 为了下次循环准备
  p = p.next
  // 3. 设置第一个节点的next 是新头 (第一个是null)
  firstNode.next = newHead
  // 4. 给头节点 赋值
  newHead = firstNode
}
```

### 时间复杂度

> O(n)

- 因为只经历了一次遍历， 所以时间复杂度是 O(n)

### 空间复杂度

> O(1)

- 定义了一些许变量来转换，所以空间复杂度是 O(1)

## 方案 2(递归形式，构建新的链表)

### 思路

> - 函数递归的过程其实就是一个入栈以及出栈的过程
> - 循环之初，可以建立一个新链表头节点
> - 当函数递归开始出栈的时候，将每个节点添加到新的链表上（可以理解为是在事件冒泡阶段触发）

> O(n)

- 因为只经历了一次遍历， 所以时间复杂度是 O(n)

### 空间复杂度

> O(n)

- 需要定义一个新链表来存储新的节点数据，所以空间复杂度是 O(n)

## 方案 3(递归形式，两两交换)

### 思路

> - 理解这个之前先理解下，如果是两个节点如何做到两两交换呢。看如下代码：
> - 递归的核心原理是：只看一层数据变化

```js
head.next.next = head
head.next = null
```
