## 回文链表

## 方案 1（快慢指针 + 栈）

### 思路：

- 通过快慢指针的小技巧，可以获取到中间节点
- 将慢指针的其余的节点 添加到栈中
- 重新将快指针指向头部，通过栈的特性(先进后出) 跟链表节点进行比较 如果一直相等表示就是回文数

### 时间复杂度：

> O(n) 时间复杂度

- 从头到尾对链表进行遍历 + 后期对链表以及数组的内容进行比较。
- 忽略常数的部分，时间复杂度就是 O(n)

### 空间复杂度

> O(n) 空间复杂度

- 额外定义一个数组来保存慢指针的节点。所以使用了 O(n)的空间复杂度。严格意义来说是 O(n/2)空间复杂度

## 方案 2（链表遍历 + 数组 + 双指针）

### 思路

- 遍历链表，将每个节点添加到数组中
- 通过前后指针来遍历数组，如果前后指针每个值都是相同的，返回 true 反之就是 false

### 时间复杂度

> O(n) 时间复杂度

- 链表的遍历 + 添加到数组 + 通过双指针进行比较。
- 去除常数系数。就是 O(n)的时间复杂度

### 空间复杂度

> O(n) 空间复杂度

- 定义一个数组用来添加节点。然后进行比较

## 方案 3（快慢指针 + 链表反转 + 节点比较）

### 思路

- 通过快慢指针来寻找中间节点
- 将慢指针其余的节点进行反转
- 头指针重新赋值，将反转后的节点跟头指针一一遍历比较

### 时间复杂度

> O(n)

- 对节点进行遍历

### 空间复杂度

> O(1)

- 定义变量进行临时存储
